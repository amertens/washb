---
title: "Wash Benefits internal R package functions"
author: "Andrew Mertens"
date: "`r Sys.Date()`"
output: 
  html_document:
    mode: selfcontained
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: true
      smooth_scroll: true
    theme: united
    highlight: pygments
vignette: >
  %\VignetteIndexEntry{washb-package-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



```{r set-options, echo=FALSE, cache=FALSE}
options(width = 200)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Vignette overview
#### WASH Benefits Bangladesh primary outcome analysis using the washb R package functions  
#### Calculate unadjusted and adjusted differences in diarrheal disease and length-for-age z-score between treatment arms for hypothesis 1 (Treatment arms vs. Control arm) and hypothesis 2 (Combined WASH vs. single intervention arms).  
  
####Input files:
 * washb-bangladesh-diar.csv
 * washb-bangladesh-enrol.csv  

 
####List and description of the functions documented in this vignette:  
 * __washb_prescreen:__  Function to pre-screen adjustment covariates -- restrict to those with a LR test P<0.2.  
 * __washb_permute:__  Conducts a permutation test of the indepdence of Y and tr, conditional on randomization block using the Wilcoxon rank-sum test statistic.
 * __washb_glm:__  Convenience wrapper function to run glm models with robust standard errors for unadjusted and adjusted estimates.
 * __washb_means:__   Means estimated with robust standard errors for the WASH Benefits trials. Calculate means for a variable along with robust sandwich SEs and 95\% confidence intervals that account for clustering within id.
 * __sandwichSE__  
 * __washb_ttest:__  Wrapper function to call the paired t-test for two different arms of the study.  
 * __washb_mh.pool:__  Estimates the Mantel-Haenszel prevalence ratio. Note: strata with no outcomes (i.e., missing PR) are dropped. This is consistent with a fixed-effects regression analysis, in which those strata would not contribute to the estimates. The arguments Y,tr,strat, below need to be from the same dataset.

 
####Relationships among functions:
__washb\_glm__ calls __washb_prescreen__, and then only covariates with a p-value>0.2 are included in the adjustment set.  
__washb\_glm__ uses __sandwichSE__ to estimate sandwich-based robust standard errors to account for clustering.  
__washb\_glm__ uses __washb\_glmFormat__ to format model output, convert coefficients to risk ratios, and return the variance/covariance matrix and a vestor of dropped observations.
  
__washb_means__ uses __sandwichSE__ to estimate sandwich-based robust standard errors to account for clustering.

#R resources
For new users of R, the following sources are helpful learning resources:
 * [Calendar of UC Berkeley D-Lab workshops](http://dlab.berkeley.edu/event-host/d-lab) (Look for R bootcamps)
 * [Datacamp: R for SAS, SPSS, and Stata users](https://www.datacamp.com/courses/r-for-sas-spss-and-stata-users-r-tutorial) (This course is for those familiar with statistical programming who only need to learn R-specific syntax)
 * [Try R codeschool](http://tryr.codeschool.com/) (An interactive introductory course)
 * [UCLA Institute For Digital Research and Education: R resources](http://statistics.ats.ucla.edu/stat/r/) (Great source for topic-specific tutorials)
 * [R -tutor introduction](http://www.r-tutor.com/r-introduction)
 * [Johns Hopkins Coursera course in R programming](https://www.coursera.org/learn/r-programming)

  
  
#Package and Data Loading
### Load in required packages:
If you are installing the packages for the first time:
```{r, eval = FALSE, tidy=TRUE}
    install.packages("sandwich")
    install.packages("lmtest")
    install.packages("coin")
    install.packages("plyr")
    install.packages("metafor")
```
  
Once packages are installed for the first time, they will be loaded along with the "washb" package when the following code is run:

```{r , results = "hide"}
library(washb)
```


```{r, include=FALSE}  
 rm(list=ls())
 baseLoc<- system.file(package="washb")  
 extPath<- file.path(baseLoc, "data")

 load(file.path(extPath, "washb_bd_enrol.Rdata"))  
 load(file.path(extPath, "washb_bd_diar.Rdata"))  
```



###Clean data  
The data in this vignette is contained in 2 files, included in the package:  
1.  __washb_bd_enrol.Rdata__, an R file of enrollment characteristics  
1.  __washb_bd_diar.Rdata__, an R file of diarrheal disease data  

These datasets are included in the washb package and can be loaded with the data() command
Load here:
```{r, eval=FALSE}
data(washb_bd_enrol)
data(washb_bd_diar)

```
  

The following code cleans and merges the enrolment and diarrhea data:
```{r, results="hide", cache=TRUE}
# drop svydate and month because they are superceded in the child level diarrhea data
  washb_bd_enrol$svydate <- NULL
  washb_bd_enrol$month <- NULL

# merge the baseline dataset to the follow-up dataset
ad <- merge(washb_bd_enrol,washb_bd_diar,by=c("dataid","clusterid","block","tr"),all.x=F,all.y=T)

# subset to the relevant measurement
# Year 1 or Year 2
ad <- subset(ad,svy==1|svy==2)

#subset the diarrhea to children <36 mos at enrollment
### (exlude new births that are not target children)
ad <- subset(ad,sibnewbirth==0)
ad <- subset(ad,gt36mos==0)

# Exclude children with missing data
ad <- subset(ad,!is.na(ad$diar7d))

#Re-order the tr factor for convenience
ad$tr <- factor(ad$tr,levels=c("Control","Water","Sanitation","Handwashing","WSH","Nutrition","Nutrition + WSH"))

#Ensure that month is coded as a factor
ad$month <- factor(ad$month)

#Sort the data for perfect replication when using V-fold cross-validation
ad <- ad[order(ad$block,ad$clusterid,ad$dataid,ad$childid),]
```
  
Now that the dataset is cleaned and merged, the washb package functions can be applied and the results will match the WASH Benefits Bangladesh primary analysis. (With the exception that the primary outcome analysis used TMLE, targeted maximum likelihood estimation, rather than GLM models in estimating the adjusted treatment effects.)  
  
  
#Function: wasb_prescreen  
Select covariates with univariate associations with the outcome of P<0.2 based on a likelihood ratio test.
 * (Excluded because only measured in target children: birthord)  
 * (Dropped due to too many missing values: asset_clock, momheight)  

###Subset to a new dataframe the variables to be screened:
```{r , results = "hide" , cache=TRUE}

Ws <- subset(ad,select=c("fracode","month","agedays","sex","momage","momedu","momheight","hfiacat","Nlt18","Ncomp","watmin","elec","floor","walls","roof","asset_wardrobe","asset_table","asset_chair","asset_khat","asset_chouki","asset_tv","asset_refrig","asset_bike","asset_moto","asset_sewmach","asset_mobile"))

```

###Run the washb_prescreen function  
The washb\_prescreen function performs a likelihood ratio test on a set of potential covariates and returns all covariates with an associated p-value<0.2. It can be called as a function on its own, and is also called internally within the washb\_glm function. Unless otherwise specified by the use, the washb\_glm function with therefore only include covariates with a LR-test p-value <0.2 in the model. See the Function: washb_glm section for more details.
```{r, warning=FALSE, message=FALSE, cache=TRUE}
prescreened_varnames<-washb_prescreen(Y=ad$diar7d,Ws,family="binomial")
```
  
__Description of output:__  
The function runs a likelihood ratio test between a generalized linear model fit to each screened variable and a null model. The first section of the output includes all screened variables and the p-values from the likelihood ratio test. The second section outputs only those variables with a p-value <0.2. The function does not currently support a user-defined p-value threshold.  
  
Use the following code to return the saved a list of variable names for the selected variables. Then, subset the covariate dataframe to only those variables:  
```{r, warning=FALSE, message=FALSE, cache=TRUE}
prescreened_varnames
prescreened_vars <- subset(Ws,select=prescreened_varnames)
#Examine the first five observations of the first selected variable:
prescreened_vars[1:5,1]

```  


#Function: washb_mean  
This function is most useful for calculating variable means and confidence intervals -- for example, calculating average compliance (uptake) within a given intervention arm, or calculating the average LAZ by arm or measurement round. In the WASH Benefits trials, the independent unit is typically the cluster, so the \code{id} argument should identify the cluster ID.  If you wish to actually compare means between groups using a difference, prevalence ratio, or incidence ratio (depending on the outcome), use \code{\link[washb]{washb_glm}}, washb\_ttest(for continuous outcomes), or washb_mh (for binary outcomes).  
Here, the mean and 95% Confidence interval for mother's age is calculated:
```{r, echo=FALSE, cache=TRUE}
washb_mean(Y=ad$momage,id=ad$clusterid,print=TRUE)

```


###Create vector of contrasts for each hypothesis to facilitate comparisons between arms.
Hypothesis 1: Each intervention arm vs. Control  
Hypothesis 2: Combined WSH versus single interventions 
```{r}
h1.contrasts <- list(
  c("Control","Water"),
  c("Control","Sanitation"),
  c("Control","Handwashing"),
  c("Control","WSH"),
  c("Control","Nutrition"),
  c("Control","Nutrition + WSH")
)
h2.contrasts <- list(
  c("Water","WSH"),
  c("Sanitation","WSH"),
  c("Handwashing","WSH")
)
```



#Function: washb_MH.pooled
### Unadjusted Mantel-Haenszel estimates 
Y=binary outcome (here, 7-day diarrheal disease recall "ad$diar7d")
tr=binary treatment group variable, 

Apply washb_MH.pooled to the water vs. control arm contrast. 
```{r, warning=FALSE, message=FALSE, cache=TRUE}
CvW<-washb_MH.pooled(Y=ad$diar7d,tr=ad$tr, contrast=c("Control","Water"), strat=ad$block,measure="RR")
#Exponentiate coefficients to calculate the prevalence ratio:
print(exp(CvW))
```
Use sapply command to efficiently apply the function to all the treatment arm contrasts
```{r, warning=FALSE, message=FALSE, cache=TRUE}
#Hypothesis 1
diff.h1 <- t(sapply(h1.contrasts,washb_MH.pooled,Y=ad$diar7d,tr=ad$tr,strat=ad$block,measure="RR"))
rownames(diff.h1) <- c("Water v C","Sanitation v C","Handwashing v C","WSH v C","Nutrition v C","Nutrition + WSH v C")
print(exp(diff.h1))

#Hypothesis 2
diff.h2 <- t(sapply(h2.contrasts,washb_MH.pooled,Y=ad$diar7d,tr=ad$tr,strat=ad$block,measure="RR"))
rownames(diff.h2) <- c("WSH v Water","WSH v Sanitation","WSH v Handwashing")
print(exp(diff.h2))
```

#Function: washb_permute
#### Non-parametric unadjusted estimates (Wilcoxon Signed Rank permutation test)
(Description to be added)  
  
Apply the washb_permute function to the Water-Control arm comparison:
```{r, eval=TRUE, warning=FALSE, message=FALSE, cache=TRUE, tidy=TRUE}
permute.C.W <- washb_permute(Y=ad$diar7d,tr=ad$tr,pair=ad$block,c("Control","Water"),nreps=100000, seed=242524)
```

Use sapply to apply the function across all arm comparisons, and assign results to matrices for hypothesis 1 and hypothesis 2 comparisons:
```{r, eval=TRUE, results = "hide", warning=FALSE, message=FALSE, cache=TRUE, tidy=TRUE}

permute.diff.h1<-t(sapply(h1.contrasts,washb_permute, Y=ad$diar7d, tr=ad$tr, pair=ad$block, nreps=10000, seed=12345))
rownames(permute.diff.h1) <- c("Water v C","Sanitation v C","Handwashing v C","WSH v C","Nutrition v C","Nutrition + WSH v C")

permute.diff.h2<-t(sapply(h2.contrasts,washb_permute, Y=ad$diar7d, tr=ad$tr, pair=ad$block, nreps=10000, seed=12345))
rownames(permute.diff.h2) <- c("WSH v Water","WSH v Sanitation","WSH v Handwashing")
```

```{r, eval=TRUE, warning=FALSE, message=FALSE, cache=TRUE, tidy=TRUE}

permute.diff.h1
permute.diff.h2

```



#Function: washb_glm 
####Unadjusted GLM
```{r, warning=FALSE, message=FALSE, cache=TRUE}

unadj.glm.h1 <- t(sapply(h1.contrasts,washb_glm,Y=ad$diar7d,tr=ad$tr,pair=ad$block, W=NULL,forcedW=NULL, id=ad$clusterid, family=binomial(link='log')))

#unadj.glm.h2 <- t(sapply(h2.contrasts,washb_glm,Y=ad$diar7d,tr=ad$tr,pair=ad$block, W=NULL,forcedW=NULL, id=ad$clusterid, family=binomial(link='log')))

```

####Adjusted GLM
```{r, warning=FALSE, message=FALSE, cache=TRUE}

adj.glm.h1 <- t(sapply(h1.contrasts,washb_glm,Y=ad$diar7d,tr=ad$tr,pair=ad$block, W=Ws,forcedW=NULL, id=ad$clusterid, family=binomial(link='log')))

#adj.glm.h2 <- t(sapply(h2.contrasts,washb_glm,Y=ad$diar7d,tr=ad$tr,pair=ad$block, W=Ws,forcedW=NULL, id=ad$clusterid, family=binomial(link='log')))

```




#LAZ Outcome Analysis  
  
Load and merge the anthropometry and enrollment datasets. and clean as for the diarheal disease analysis shown above (cleaning code ommitted)
```{r, eval=FALSE}
data(washb_bd_anthro)
data(washb_bd_enrol)

ad <- merge(washb_bd_enrol,washb_bd_anthro,by=c("dataid","clusterid","block","tr"),all.x=F,all.y=T)
```

```{r, include=FALSE, eval=TRUE, cache=TRUE}
load(file.path(extPath, "washb_bd_enrol.Rdata"))  
load(file.path(extPath, "washb_bd_anthro.Rdata"))  
  washb_bd_enrol$svydate <- NULL
  washb_bd_enrol$month <- NULL
ad <- merge(washb_bd_enrol,washb_bd_anthro,by=c("dataid","clusterid","block","tr"),all.x=F,all.y=T)
ad <- subset(ad,svy==2)
ad <- subset(ad,tchild=="Target child")

# Drop children with extreme LAZ values
ad <- subset(ad,laz_x!=1)

ad$tr <- factor(ad$tr,levels=c("Control","Water","Sanitation","Handwashing","WSH","Nutrition","Nutrition + WSH"))
ad$month <- factor(ad$month)
ad <- ad[order(ad$block,ad$clusterid,ad$dataid,ad$childid),]

Ws <- subset(ad,select=c("fracode","month","aged","sex","birthord","momage","momedu","momheight","hfiacat","Nlt18","Ncomp","watmin","elec","floor","walls","roof","asset_wardrobe","asset_table","asset_chair","asset_khat","asset_chouki","asset_tv","asset_refrig","asset_bike","asset_moto","asset_sewmach","asset_mobile"))
```


#Function: washb_paired.ttest  
Function to call the paired t-test for two different arms of the study. It estimates the paired t-test for differences in means paired within randomization blocks. This function should be used for the unadjusted analysis of continious outcomes.


```{r, cache=TRUE}
#Run washb_paired.ttest on water vs. control arm comparison
washb_paired.ttest(Y=ad$laz,tr=ad$tr,strat=ad$block, contrast=c("Control","Water"))

#Use sapply to apply across all contrasts
diff.h1LAZ <- t(sapply(h1.contrasts,washb_paired.ttest,Y=ad$laz,tr=ad$tr,strat=ad$block))
rownames(diff.h1LAZ) <- c("Water v C","Sanitation v C","Handwashing v C","WSH v C","Nutrition v C","Nutrition + WSH v C")
round(print(diff.h1LAZ),3)
```

####Unadjusted GLM
```{r, warning=FALSE, message=FALSE, eval=TRUE, cache=TRUE}
####Unadjusted GLM

unadj.glm.h1LAZ <- t(sapply(h1.contrasts,washb_glm,Y=ad$laz,tr=ad$tr,pair=ad$block, W=NULL,forcedW=NULL, id=ad$clusterid, family="gaussian"))

unadj.glm.h2LAZ <- t(sapply(h2.contrasts,washb_glm,Y=ad$laz,tr=ad$tr,pair=ad$block, W=NULL,forcedW=NULL, id=ad$clusterid, family="gaussian"))

```

####Adjusted GLM
```{r, warning=FALSE, message=FALSE, cache=TRUE}

adj.glm.h1LAZ <- t(sapply(h1.contrasts,washb_glm,Y=ad$laz,tr=ad$tr,pair=ad$block, W=Ws,forcedW=NULL, id=ad$clusterid, family="gaussian"))

adj.glm.h2LAZ <- t(sapply(h2.contrasts,washb_glm,Y=ad$laz,tr=ad$tr,pair=ad$block, W=Ws,forcedW=NULL, id=ad$clusterid, family="gaussian"))

```
  
  
  
#Table of Primary Outcome Results  

###7-day diarrheal disease recall outcome  

Contrast v. control | Estimator | PR | 95% CI | SE | P-value  
--------------------|-----------|----|--------|----|--------  
Water | Unadjusted MH  | `r round(exp(diff.h1[1,1]),2)` | `r round(exp(diff.h1[1,3:4]),2)` | `r round(diff.h1[1,2],4)` | `r round(diff.h1[1,6],4)`
Water | Unadjusted GLM |  `r round(unadj.glm.h1[[1]][2,1],2)` |(`r round(unadj.glm.h1[[1]][2,2:3],2)`) | `r round(unadj.glm.h1[[7]][2,2],4)` | `r round(unadj.glm.h1[[7]][2,4],4)`
Water | Adjusted GLM | `r round(adj.glm.h1[[1]][2,1],2)` |(`r round(adj.glm.h1[[1]][2,2:3],2)`) | `r round(adj.glm.h1[[7]][2,2],4)` | `r round(adj.glm.h1[[7]][2,4],4)`
Water | Adjusted GLM + TMLE |  | | | 
Water | Adjusted SL + TMLE |  | | |   
Water | Wilcoxon  permutation test |  | |`r permute.diff.h1[1]` | 
-----------------------------------------|--------------------------------------|---------------|-----------------------|------------|-----------  
Sanitation | Unadjusted MH | `r round(exp(diff.h1[2,1]),2)` |(`r round(exp(diff.h1[2,3:4]),2)`) | `r round(diff.h1[2,2],4)`| `r round(diff.h1[2,6],4)`
Sanitation | Unadjusted GLM |  `r round(unadj.glm.h1[[2]][2,1],2)` |(`r round(unadj.glm.h1[[2]][2,2:3],2)`) | `r round(unadj.glm.h1[[8]][2,2],4)` | `r round(unadj.glm.h1[[8]][2,4],4)`
Sanitation | Adjusted GLM | `r round(adj.glm.h1[[2]][2,1],2)` |(`r round(adj.glm.h1[[2]][2,2:3],2)`) | `r round(adj.glm.h1[[8]][2,2],4)` | `r round(adj.glm.h1[[8]][2,4],4)`
Sanitation | Adjusted GLM + TMLE | | | | 
Sanitation | Adjusted SL + TMLE | | | | 
Sanitation | Wilcoxon  permutation test |  | |`r permute.diff.h1[2]` | 
-----------------------------------------|--------------------------------------|---------------|-----------------------|------------|-----------
Handwashing | Unadjusted MH | `r round(exp(diff.h1[3,1]),2)` |(`r round(exp(diff.h1[3,3:4]),2)`) | `r round(diff.h1[3,2],4)`| `r round(diff.h1[3,6],4)`
Handwashing | Unadjusted GLM |  `r round(unadj.glm.h1[[3]][2,1],2)` |(`r round(unadj.glm.h1[[3]][2,2:3],2)`) | `r round(unadj.glm.h1[[9]][2,2],4)` | `r round(unadj.glm.h1[[9]][2,4],4)`
Handwashing | Adjusted GLM | `r round(adj.glm.h1[[3]][2,1],2)` |(`r round(adj.glm.h1[[3]][2,2:3],2)`) | `r round(adj.glm.h1[[9]][2,2],4)` | `r round(adj.glm.h1[[9]][2,4],4)`
Handwashing | Adjusted GLM + TMLE | | | | 
Handwashing | Adjusted SL + TMLE | | | | 
Handwashing | Wilcoxon  permutation test |  | |`r permute.diff.h1[3]` | 
-----------------------------------------|--------------------------------------|---------------|-----------------------|------------|-----------
WSH | Unadjusted MH | `r round(exp(diff.h1[4,1]),2)` |(`r round(exp(diff.h1[4,3:4]),2)`) | `r round(diff.h1[4,2],4)`| `r round(diff.h1[4,6],4)`
WSH | Unadjusted GLM |  `r round(unadj.glm.h1[[4]][2,1],2)` |(`r round(unadj.glm.h1[[4]][2,2:3],2)`) | `r round(unadj.glm.h1[[10]][2,2],4)` | `r round(unadj.glm.h1[[10]][2,4],4)`
WSH | Adjusted GLM | `r round(adj.glm.h1[[4]][2,1],2)` |(`r round(adj.glm.h1[[4]][2,2:3],2)`) | `r round(adj.glm.h1[[10]][2,2],4)` | `r round(adj.glm.h1[[10]][2,4],4)`
WSH | Adjusted GLM + TMLE | | | | 
WSH | Adjusted SL + TMLE | | | | 
WSH | Wilcoxon  permutation test |  | |`r permute.diff.h1[4]` | 
-----------------------------------------|--------------------------------------|---------------|-----------------------|------------|-----------
Nutrition | Unadjusted MH | `r round(exp(diff.h1[5,1]),2)` |(`r round(exp(diff.h1[5,3:4]),2)`) | `r round(diff.h1[5,2],4)`| `r round(diff.h1[5,6],4)`
Nutrition | Unadjusted GLM |  `r round(unadj.glm.h1[[5]][2,1],2)` |(`r round(unadj.glm.h1[[5]][2,2:3],2)`) | `r round(unadj.glm.h1[[11]][2,2],4)` | `r round(unadj.glm.h1[[11]][2,4],4)`
Nutrition | Adjusted GLM | `r round(adj.glm.h1[[5]][2,1],2)` |(`r round(adj.glm.h1[[5]][2,2:3],2)`) | `r round(adj.glm.h1[[11]][2,2],4)` | `r round(adj.glm.h1[[11]][2,4],4)`
Nutrition | Adjusted GLM + TMLE | | | | 
Nutrition | Adjusted SL + TMLE | | | | 
Nutrition | Wilcoxon  permutation test |  | |`r permute.diff.h1[5]` | 
-----------------------------------------|--------------------------------------|---------------|-----------------------|------------|-----------
WSH+N | Unadjusted MH | `r round(exp(diff.h1[6,1]),2)` |(`r round(exp(diff.h1[6,3:4]),2)`) | `r round(diff.h1[6,2],4)`| `r round(diff.h1[6,6],4)`
WSH+N | Unadjusted GLM |  `r round(unadj.glm.h1[[6]][2,1],2)` |(`r round(unadj.glm.h1[[6]][2,2:3],2)`) | `r round(unadj.glm.h1[[12]][2,2],4)` | `r round(unadj.glm.h1[[12]][2,4],4)`
WSH+N | Adjusted GLM | `r round(adj.glm.h1[[6]][2,1],2)` |(`r round(adj.glm.h1[[6]][2,2:3],2)`) | `r round(adj.glm.h1[[12]][2,2],4)` | `r round(adj.glm.h1[[12]][2,4],4)`
WSH+N | Adjusted GLM + TMLE | | | | 
WSH+N | Adjusted SL + TMLE | | | | 
WSH+N | Wilcoxon  permutation test |  | |`r permute.diff.h1[6]` | 
-----------------------------------------|--------------------------------------|---------------|--------------|------------|-------------

  
  
  
  
  
  
###Length-for-Age Z-score outcome  

Contrast v. control | Estimator | Difference | 95% CI | t-stat/SE | P-value
--------------------|-----------|------------|--------|----|--------
Water | Unadjusted ttest | `r round(diff.h1LAZ[1,1],2)` |(`r round((diff.h1LAZ[1,2:3]),2)`) | t-stat:  `r round(diff.h1LAZ[1,4],2)`| `r round(diff.h1LAZ[1,5],3)`
Water | Unadjusted GLM |  `r round(unadj.glm.h1LAZ[[1]][2,1],2)` |(`r round(unadj.glm.h1LAZ[[1]][2,2:3],2)`) |SE:  `r round(unadj.glm.h1LAZ[[7]][2,2],2)` | `r round(unadj.glm.h1LAZ[[7]][2,4],3)`
Water | Adjusted GLM | `r round(adj.glm.h1LAZ[[1]][2,1],2)` |(`r round(adj.glm.h1LAZ[[1]][2,2:3],2)`) |SE:  `r round(adj.glm.h1LAZ[[7]][2,2],2)` | `r round(adj.glm.h1LAZ[[7]][2,4],3)`
Water | Adjusted GLM + TMLE |  | | | 
Water | Adjusted SL + TMLE |  | | | 
Water | Wilcoxon  permutation test |  | | | 
-----------------------------------------|--------------------------------------|---------------|--------------|------------|-------------
Sanitation | Unadjusted ttest | `r round((diff.h1LAZ[2,1]),2)` |(`r round((diff.h1LAZ[2,2:3]),2)`) | `r round(diff.h1LAZ[2,4],2)`| `r round(diff.h1LAZ[2,5],3)`
Sanitation | Unadjusted GLM |  `r round(unadj.glm.h1LAZ[[2]][2,1],2)` |(`r round(unadj.glm.h1LAZ[[2]][2,2:3],2)`) | `r round(unadj.glm.h1LAZ[[8]][2,2],2)` | `r round(unadj.glm.h1LAZ[[8]][2,4],3)`
Sanitation | Adjusted GLM | `r round(adj.glm.h1LAZ[[2]][2,1],2)` |(`r round(adj.glm.h1LAZ[[2]][2,2:3],2)`) | `r round(adj.glm.h1LAZ[[8]][2,2],2)` | `r round(adj.glm.h1LAZ[[8]][2,4],3)`
Sanitation | Adjusted GLM + TMLE | | | | 
Sanitation | Adjusted SL + TMLE | | | | 
-----------------------------------------|--------------------------------------|---------------|--------------|------------|-------------
Handwashing | Unadjusted ttest | `r round((diff.h1LAZ[3,1]),2)` |(`r round((diff.h1LAZ[3,2:3]),2)`) | `r round(diff.h1LAZ[3,4],2)`| `r round(diff.h1LAZ[3,5],3)`
Handwashing | Unadjusted GLM |  `r round(unadj.glm.h1LAZ[[3]][2,1],2)` |(`r round(unadj.glm.h1LAZ[[3]][2,2:3],2)`) | `r round(unadj.glm.h1LAZ[[9]][2,2],2)` | `r round(unadj.glm.h1LAZ[[9]][2,4],3)`
Handwashing | Adjusted GLM | `r round(adj.glm.h1LAZ[[3]][2,1],2)` |(`r round(adj.glm.h1LAZ[[3]][2,2:3],2)`) | `r round(adj.glm.h1LAZ[[9]][2,2],2)` | `r round(adj.glm.h1LAZ[[9]][2,4],3)`
Handwashing | Adjusted GLM + TMLE | | | | 
Handwashing | Adjusted SL + TMLE | | | | 
-----------------------------------------|--------------------------------------|---------------|--------------|------------|-------------
WSH | Unadjusted ttest | `r round((diff.h1LAZ[4,1]),2)` |(`r round((diff.h1LAZ[4,2:3]),2)`) | `r round(diff.h1LAZ[4,4],2)`| `r round(diff.h1LAZ[4,5],3)`
WSH | Unadjusted GLM |  `r round(unadj.glm.h1LAZ[[4]][2,1],2)` |(`r round(unadj.glm.h1LAZ[[4]][2,2:3],2)`) | `r round(unadj.glm.h1LAZ[[10]][2,2],2)` | `r round(unadj.glm.h1LAZ[[10]][2,4],3)`
WSH | Adjusted GLM | `r round(adj.glm.h1LAZ[[4]][2,1],2)` |(`r round(adj.glm.h1LAZ[[4]][2,2:3],2)`) | `r round(adj.glm.h1LAZ[[10]][2,2],2)` | `r round(adj.glm.h1LAZ[[10]][2,4],3)`
WSH | Adjusted GLM + TMLE | | | | 
WSH | Adjusted SL + TMLE | | | | 
-----------------------------------------|--------------------------------------|---------------|--------------|------------|-------------
Nutrition | Unadjusted ttest | `r round((diff.h1LAZ[5,1]),2)` |(`r round((diff.h1LAZ[5,2:3]),2)`) | `r round(diff.h1LAZ[5,4],4)`| `r round(diff.h1LAZ[5,5],3)`
Nutrition | Unadjusted GLM |  `r round(unadj.glm.h1LAZ[[5]][2,1],2)` |(`r round(unadj.glm.h1LAZ[[5]][2,2:3],2)`) | `r round(unadj.glm.h1LAZ[[11]][2,2],4)` | `r round(unadj.glm.h1LAZ[[11]][2,4],4)`
Nutrition | Adjusted GLM | `r round(adj.glm.h1LAZ[[5]][2,1],2)` |(`r round(adj.glm.h1LAZ[[5]][2,2:3],2)`) | `r round(adj.glm.h1LAZ[[11]][2,2],4)` | `r round(adj.glm.h1LAZ[[11]][2,4],4)`
Nutrition | Adjusted GLM + TMLE | | | | 
Nutrition | Adjusted SL + TMLE | | | | 
-----------------------------------------|--------------------------------------|---------------|--------------|------------|-------------
WSH+N | Unadjusted ttest | `r round((diff.h1LAZ[6,1]),2)` |(`r round((diff.h1LAZ[6,2:3]),2)`) | `r round(diff.h1LAZ[6,4],4)`| `r round(diff.h1LAZ[6,5],3)`
WSH+N | Unadjusted GLM |  `r round(unadj.glm.h1LAZ[[6]][2,1],2)` |(`r round(unadj.glm.h1LAZ[[6]][2,2:3],2)`) | `r round(unadj.glm.h1LAZ[[12]][2,2],2)` | `r round(unadj.glm.h1LAZ[[12]][2,4],3)`
WSH+N | Adjusted GLM | `r round(adj.glm.h1LAZ[[6]][2,1],2)` |(`r round(adj.glm.h1LAZ[[6]][2,2:3],2)`) | `r round(adj.glm.h1LAZ[[12]][2,2],2)` | `r round(adj.glm.h1LAZ[[12]][2,4],3)`
WSH+N | Adjusted GLM + TMLE | | | | 
WSH+N | Adjusted SL + TMLE | | | | 
-----------------------------------------|--------------------------------------|---------------|--------------|------------|-------------



